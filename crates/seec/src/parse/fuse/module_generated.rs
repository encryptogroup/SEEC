// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod fuse {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod ir {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PRIMITIVE_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PRIMITIVE_TYPE: i8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PRIMITIVE_TYPE: [PrimitiveType; 11] = [
  PrimitiveType::Bool,
  PrimitiveType::Int8,
  PrimitiveType::Int16,
  PrimitiveType::Int32,
  PrimitiveType::Int64,
  PrimitiveType::UInt8,
  PrimitiveType::UInt16,
  PrimitiveType::UInt32,
  PrimitiveType::UInt64,
  PrimitiveType::Float,
  PrimitiveType::Double,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct PrimitiveType(pub i8);
#[allow(non_upper_case_globals)]
impl PrimitiveType {
  pub const Bool: Self = Self(0);
  pub const Int8: Self = Self(1);
  pub const Int16: Self = Self(2);
  pub const Int32: Self = Self(3);
  pub const Int64: Self = Self(4);
  pub const UInt8: Self = Self(5);
  pub const UInt16: Self = Self(6);
  pub const UInt32: Self = Self(7);
  pub const UInt64: Self = Self(8);
  pub const Float: Self = Self(9);
  pub const Double: Self = Self(10);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 10;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Bool,
    Self::Int8,
    Self::Int16,
    Self::Int32,
    Self::Int64,
    Self::UInt8,
    Self::UInt16,
    Self::UInt32,
    Self::UInt64,
    Self::Float,
    Self::Double,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Bool => Some("Bool"),
      Self::Int8 => Some("Int8"),
      Self::Int16 => Some("Int16"),
      Self::Int32 => Some("Int32"),
      Self::Int64 => Some("Int64"),
      Self::UInt8 => Some("UInt8"),
      Self::UInt16 => Some("UInt16"),
      Self::UInt32 => Some("UInt32"),
      Self::UInt64 => Some("UInt64"),
      Self::Float => Some("Float"),
      Self::Double => Some("Double"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for PrimitiveType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for PrimitiveType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for PrimitiveType {
    type Output = PrimitiveType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for PrimitiveType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for PrimitiveType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for PrimitiveType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SECURITY_LEVEL: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SECURITY_LEVEL: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SECURITY_LEVEL: [SecurityLevel; 2] = [
  SecurityLevel::Secure,
  SecurityLevel::Plaintext,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SecurityLevel(pub i8);
#[allow(non_upper_case_globals)]
impl SecurityLevel {
  pub const Secure: Self = Self(0);
  pub const Plaintext: Self = Self(1);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Secure,
    Self::Plaintext,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Secure => Some("Secure"),
      Self::Plaintext => Some("Plaintext"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SecurityLevel {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SecurityLevel {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SecurityLevel {
    type Output = SecurityLevel;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SecurityLevel {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SecurityLevel {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SecurityLevel {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PRIMITIVE_OPERATION: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PRIMITIVE_OPERATION: i8 = 27;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PRIMITIVE_OPERATION: [PrimitiveOperation; 28] = [
  PrimitiveOperation::Custom,
  PrimitiveOperation::And,
  PrimitiveOperation::Xor,
  PrimitiveOperation::Not,
  PrimitiveOperation::Or,
  PrimitiveOperation::Nand,
  PrimitiveOperation::Nor,
  PrimitiveOperation::Xnor,
  PrimitiveOperation::Gt,
  PrimitiveOperation::Ge,
  PrimitiveOperation::Lt,
  PrimitiveOperation::Le,
  PrimitiveOperation::Eq,
  PrimitiveOperation::Add,
  PrimitiveOperation::Mul,
  PrimitiveOperation::Div,
  PrimitiveOperation::Neg,
  PrimitiveOperation::Sub,
  PrimitiveOperation::Loop,
  PrimitiveOperation::CallSubcircuit,
  PrimitiveOperation::Split,
  PrimitiveOperation::Merge,
  PrimitiveOperation::Input,
  PrimitiveOperation::Output,
  PrimitiveOperation::Constant,
  PrimitiveOperation::Mux,
  PrimitiveOperation::SelectOffset,
  PrimitiveOperation::Square,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct PrimitiveOperation(pub i8);
#[allow(non_upper_case_globals)]
impl PrimitiveOperation {
  pub const Custom: Self = Self(0);
  pub const And: Self = Self(1);
  pub const Xor: Self = Self(2);
  pub const Not: Self = Self(3);
  pub const Or: Self = Self(4);
  pub const Nand: Self = Self(5);
  pub const Nor: Self = Self(6);
  pub const Xnor: Self = Self(7);
  pub const Gt: Self = Self(8);
  pub const Ge: Self = Self(9);
  pub const Lt: Self = Self(10);
  pub const Le: Self = Self(11);
  pub const Eq: Self = Self(12);
  pub const Add: Self = Self(13);
  pub const Mul: Self = Self(14);
  pub const Div: Self = Self(15);
  pub const Neg: Self = Self(16);
  pub const Sub: Self = Self(17);
  pub const Loop: Self = Self(18);
  pub const CallSubcircuit: Self = Self(19);
  pub const Split: Self = Self(20);
  pub const Merge: Self = Self(21);
  pub const Input: Self = Self(22);
  pub const Output: Self = Self(23);
  pub const Constant: Self = Self(24);
  pub const Mux: Self = Self(25);
  pub const SelectOffset: Self = Self(26);
  pub const Square: Self = Self(27);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 27;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Custom,
    Self::And,
    Self::Xor,
    Self::Not,
    Self::Or,
    Self::Nand,
    Self::Nor,
    Self::Xnor,
    Self::Gt,
    Self::Ge,
    Self::Lt,
    Self::Le,
    Self::Eq,
    Self::Add,
    Self::Mul,
    Self::Div,
    Self::Neg,
    Self::Sub,
    Self::Loop,
    Self::CallSubcircuit,
    Self::Split,
    Self::Merge,
    Self::Input,
    Self::Output,
    Self::Constant,
    Self::Mux,
    Self::SelectOffset,
    Self::Square,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Custom => Some("Custom"),
      Self::And => Some("And"),
      Self::Xor => Some("Xor"),
      Self::Not => Some("Not"),
      Self::Or => Some("Or"),
      Self::Nand => Some("Nand"),
      Self::Nor => Some("Nor"),
      Self::Xnor => Some("Xnor"),
      Self::Gt => Some("Gt"),
      Self::Ge => Some("Ge"),
      Self::Lt => Some("Lt"),
      Self::Le => Some("Le"),
      Self::Eq => Some("Eq"),
      Self::Add => Some("Add"),
      Self::Mul => Some("Mul"),
      Self::Div => Some("Div"),
      Self::Neg => Some("Neg"),
      Self::Sub => Some("Sub"),
      Self::Loop => Some("Loop"),
      Self::CallSubcircuit => Some("CallSubcircuit"),
      Self::Split => Some("Split"),
      Self::Merge => Some("Merge"),
      Self::Input => Some("Input"),
      Self::Output => Some("Output"),
      Self::Constant => Some("Constant"),
      Self::Mux => Some("Mux"),
      Self::SelectOffset => Some("SelectOffset"),
      Self::Square => Some("Square"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for PrimitiveOperation {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for PrimitiveOperation {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for PrimitiveOperation {
    type Output = PrimitiveOperation;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for PrimitiveOperation {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for PrimitiveOperation {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for PrimitiveOperation {}
pub enum DataTypeTableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DataTypeTable<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DataTypeTable<'a> {
  type Inner = DataTypeTable<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DataTypeTable<'a> {
  pub const VT_PRIMITIVE_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_SECURITY_LEVEL: flatbuffers::VOffsetT = 6;
  pub const VT_SHAPE: flatbuffers::VOffsetT = 8;
  pub const VT_DATA_TYPE_ANNOTATIONS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DataTypeTable { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DataTypeTableArgs<'args>
  ) -> flatbuffers::WIPOffset<DataTypeTable<'bldr>> {
    let mut builder = DataTypeTableBuilder::new(_fbb);
    if let Some(x) = args.data_type_annotations { builder.add_data_type_annotations(x); }
    if let Some(x) = args.shape { builder.add_shape(x); }
    builder.add_security_level(args.security_level);
    builder.add_primitive_type(args.primitive_type);
    builder.finish()
  }


  #[inline]
  pub fn primitive_type(&self) -> PrimitiveType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<PrimitiveType>(DataTypeTable::VT_PRIMITIVE_TYPE, Some(PrimitiveType::Bool)).unwrap()}
  }
  #[inline]
  pub fn security_level(&self) -> SecurityLevel {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SecurityLevel>(DataTypeTable::VT_SECURITY_LEVEL, Some(SecurityLevel::Secure)).unwrap()}
  }
  #[inline]
  pub fn shape(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(DataTypeTable::VT_SHAPE, None)}
  }
  #[inline]
  pub fn data_type_annotations(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataTypeTable::VT_DATA_TYPE_ANNOTATIONS, None)}
  }
}

impl flatbuffers::Verifiable for DataTypeTable<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<PrimitiveType>("primitive_type", Self::VT_PRIMITIVE_TYPE, false)?
     .visit_field::<SecurityLevel>("security_level", Self::VT_SECURITY_LEVEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("shape", Self::VT_SHAPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("data_type_annotations", Self::VT_DATA_TYPE_ANNOTATIONS, false)?
     .finish();
    Ok(())
  }
}
pub struct DataTypeTableArgs<'a> {
    pub primitive_type: PrimitiveType,
    pub security_level: SecurityLevel,
    pub shape: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub data_type_annotations: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DataTypeTableArgs<'a> {
  #[inline]
  fn default() -> Self {
    DataTypeTableArgs {
      primitive_type: PrimitiveType::Bool,
      security_level: SecurityLevel::Secure,
      shape: None,
      data_type_annotations: None,
    }
  }
}

pub struct DataTypeTableBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DataTypeTableBuilder<'a, 'b> {
  #[inline]
  pub fn add_primitive_type(&mut self, primitive_type: PrimitiveType) {
    self.fbb_.push_slot::<PrimitiveType>(DataTypeTable::VT_PRIMITIVE_TYPE, primitive_type, PrimitiveType::Bool);
  }
  #[inline]
  pub fn add_security_level(&mut self, security_level: SecurityLevel) {
    self.fbb_.push_slot::<SecurityLevel>(DataTypeTable::VT_SECURITY_LEVEL, security_level, SecurityLevel::Secure);
  }
  #[inline]
  pub fn add_shape(&mut self, shape: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataTypeTable::VT_SHAPE, shape);
  }
  #[inline]
  pub fn add_data_type_annotations(&mut self, data_type_annotations: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataTypeTable::VT_DATA_TYPE_ANNOTATIONS, data_type_annotations);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DataTypeTableBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DataTypeTableBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DataTypeTable<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DataTypeTable<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DataTypeTable");
      ds.field("primitive_type", &self.primitive_type());
      ds.field("security_level", &self.security_level());
      ds.field("shape", &self.shape());
      ds.field("data_type_annotations", &self.data_type_annotations());
      ds.finish()
  }
}
pub enum NodeTableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NodeTable<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NodeTable<'a> {
  type Inner = NodeTable<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> NodeTable<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_INPUT_DATATYPES: flatbuffers::VOffsetT = 6;
  pub const VT_INPUT_IDENTIFIERS: flatbuffers::VOffsetT = 8;
  pub const VT_INPUT_OFFSETS: flatbuffers::VOffsetT = 10;
  pub const VT_OPERATION: flatbuffers::VOffsetT = 12;
  pub const VT_CUSTOM_OP_NAME: flatbuffers::VOffsetT = 14;
  pub const VT_SUBCIRCUIT_NAME: flatbuffers::VOffsetT = 16;
  pub const VT_PAYLOAD: flatbuffers::VOffsetT = 18;
  pub const VT_NUM_OF_OUTPUTS: flatbuffers::VOffsetT = 20;
  pub const VT_OUTPUT_DATATYPES: flatbuffers::VOffsetT = 22;
  pub const VT_NODE_ANNOTATIONS: flatbuffers::VOffsetT = 24;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    NodeTable { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args NodeTableArgs<'args>
  ) -> flatbuffers::WIPOffset<NodeTable<'bldr>> {
    let mut builder = NodeTableBuilder::new(_fbb);
    builder.add_id(args.id);
    if let Some(x) = args.node_annotations { builder.add_node_annotations(x); }
    if let Some(x) = args.output_datatypes { builder.add_output_datatypes(x); }
    builder.add_num_of_outputs(args.num_of_outputs);
    if let Some(x) = args.payload { builder.add_payload(x); }
    if let Some(x) = args.subcircuit_name { builder.add_subcircuit_name(x); }
    if let Some(x) = args.custom_op_name { builder.add_custom_op_name(x); }
    if let Some(x) = args.input_offsets { builder.add_input_offsets(x); }
    if let Some(x) = args.input_identifiers { builder.add_input_identifiers(x); }
    if let Some(x) = args.input_datatypes { builder.add_input_datatypes(x); }
    builder.add_operation(args.operation);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(NodeTable::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &NodeTable) -> bool {
    self.id() < o.id()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: u64) -> ::core::cmp::Ordering {
    let key = self.id();
    key.cmp(&val)
  }
  #[inline]
  pub fn input_datatypes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataTypeTable<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataTypeTable>>>>(NodeTable::VT_INPUT_DATATYPES, None)}
  }
  #[inline]
  pub fn input_identifiers(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(NodeTable::VT_INPUT_IDENTIFIERS, None)}
  }
  #[inline]
  pub fn input_offsets(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(NodeTable::VT_INPUT_OFFSETS, None)}
  }
  #[inline]
  pub fn operation(&self) -> PrimitiveOperation {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<PrimitiveOperation>(NodeTable::VT_OPERATION, Some(PrimitiveOperation::Custom)).unwrap()}
  }
  #[inline]
  pub fn custom_op_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NodeTable::VT_CUSTOM_OP_NAME, None)}
  }
  #[inline]
  pub fn subcircuit_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NodeTable::VT_SUBCIRCUIT_NAME, None)}
  }
  #[inline]
  pub fn payload(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(NodeTable::VT_PAYLOAD, None)}
  }
  #[inline]
  pub fn num_of_outputs(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(NodeTable::VT_NUM_OF_OUTPUTS, Some(1)).unwrap()}
  }
  #[inline]
  pub fn output_datatypes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataTypeTable<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataTypeTable>>>>(NodeTable::VT_OUTPUT_DATATYPES, None)}
  }
  #[inline]
  pub fn node_annotations(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NodeTable::VT_NODE_ANNOTATIONS, None)}
  }
}

impl flatbuffers::Verifiable for NodeTable<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DataTypeTable>>>>("input_datatypes", Self::VT_INPUT_DATATYPES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>("input_identifiers", Self::VT_INPUT_IDENTIFIERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("input_offsets", Self::VT_INPUT_OFFSETS, false)?
     .visit_field::<PrimitiveOperation>("operation", Self::VT_OPERATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("custom_op_name", Self::VT_CUSTOM_OP_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("subcircuit_name", Self::VT_SUBCIRCUIT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("payload", Self::VT_PAYLOAD, false)?
     .visit_field::<u32>("num_of_outputs", Self::VT_NUM_OF_OUTPUTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DataTypeTable>>>>("output_datatypes", Self::VT_OUTPUT_DATATYPES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("node_annotations", Self::VT_NODE_ANNOTATIONS, false)?
     .finish();
    Ok(())
  }
}
pub struct NodeTableArgs<'a> {
    pub id: u64,
    pub input_datatypes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataTypeTable<'a>>>>>,
    pub input_identifiers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
    pub input_offsets: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub operation: PrimitiveOperation,
    pub custom_op_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub subcircuit_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub payload: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub num_of_outputs: u32,
    pub output_datatypes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataTypeTable<'a>>>>>,
    pub node_annotations: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for NodeTableArgs<'a> {
  #[inline]
  fn default() -> Self {
    NodeTableArgs {
      id: 0,
      input_datatypes: None,
      input_identifiers: None,
      input_offsets: None,
      operation: PrimitiveOperation::Custom,
      custom_op_name: None,
      subcircuit_name: None,
      payload: None,
      num_of_outputs: 1,
      output_datatypes: None,
      node_annotations: None,
    }
  }
}

pub struct NodeTableBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NodeTableBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u64) {
    self.fbb_.push_slot::<u64>(NodeTable::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_input_datatypes(&mut self, input_datatypes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DataTypeTable<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NodeTable::VT_INPUT_DATATYPES, input_datatypes);
  }
  #[inline]
  pub fn add_input_identifiers(&mut self, input_identifiers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NodeTable::VT_INPUT_IDENTIFIERS, input_identifiers);
  }
  #[inline]
  pub fn add_input_offsets(&mut self, input_offsets: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NodeTable::VT_INPUT_OFFSETS, input_offsets);
  }
  #[inline]
  pub fn add_operation(&mut self, operation: PrimitiveOperation) {
    self.fbb_.push_slot::<PrimitiveOperation>(NodeTable::VT_OPERATION, operation, PrimitiveOperation::Custom);
  }
  #[inline]
  pub fn add_custom_op_name(&mut self, custom_op_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NodeTable::VT_CUSTOM_OP_NAME, custom_op_name);
  }
  #[inline]
  pub fn add_subcircuit_name(&mut self, subcircuit_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NodeTable::VT_SUBCIRCUIT_NAME, subcircuit_name);
  }
  #[inline]
  pub fn add_payload(&mut self, payload: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NodeTable::VT_PAYLOAD, payload);
  }
  #[inline]
  pub fn add_num_of_outputs(&mut self, num_of_outputs: u32) {
    self.fbb_.push_slot::<u32>(NodeTable::VT_NUM_OF_OUTPUTS, num_of_outputs, 1);
  }
  #[inline]
  pub fn add_output_datatypes(&mut self, output_datatypes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DataTypeTable<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NodeTable::VT_OUTPUT_DATATYPES, output_datatypes);
  }
  #[inline]
  pub fn add_node_annotations(&mut self, node_annotations: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NodeTable::VT_NODE_ANNOTATIONS, node_annotations);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NodeTableBuilder<'a, 'b> {
    let start = _fbb.start_table();
    NodeTableBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NodeTable<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for NodeTable<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("NodeTable");
      ds.field("id", &self.id());
      ds.field("input_datatypes", &self.input_datatypes());
      ds.field("input_identifiers", &self.input_identifiers());
      ds.field("input_offsets", &self.input_offsets());
      ds.field("operation", &self.operation());
      ds.field("custom_op_name", &self.custom_op_name());
      ds.field("subcircuit_name", &self.subcircuit_name());
      ds.field("payload", &self.payload());
      ds.field("num_of_outputs", &self.num_of_outputs());
      ds.field("output_datatypes", &self.output_datatypes());
      ds.field("node_annotations", &self.node_annotations());
      ds.finish()
  }
}
pub enum CircuitTableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CircuitTable<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CircuitTable<'a> {
  type Inner = CircuitTable<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CircuitTable<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_INPUTS: flatbuffers::VOffsetT = 6;
  pub const VT_INPUT_DATATYPES: flatbuffers::VOffsetT = 8;
  pub const VT_OUTPUTS: flatbuffers::VOffsetT = 10;
  pub const VT_OUTPUT_DATATYPES: flatbuffers::VOffsetT = 12;
  pub const VT_NODES: flatbuffers::VOffsetT = 14;
  pub const VT_CIRCUIT_ANNOTATIONS: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CircuitTable { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CircuitTableArgs<'args>
  ) -> flatbuffers::WIPOffset<CircuitTable<'bldr>> {
    let mut builder = CircuitTableBuilder::new(_fbb);
    if let Some(x) = args.circuit_annotations { builder.add_circuit_annotations(x); }
    if let Some(x) = args.nodes { builder.add_nodes(x); }
    if let Some(x) = args.output_datatypes { builder.add_output_datatypes(x); }
    if let Some(x) = args.outputs { builder.add_outputs(x); }
    if let Some(x) = args.input_datatypes { builder.add_input_datatypes(x); }
    if let Some(x) = args.inputs { builder.add_inputs(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CircuitTable::VT_NAME, None).unwrap()}
  }
  #[inline]
  pub fn inputs(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(CircuitTable::VT_INPUTS, None)}
  }
  #[inline]
  pub fn input_datatypes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataTypeTable<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataTypeTable>>>>(CircuitTable::VT_INPUT_DATATYPES, None)}
  }
  #[inline]
  pub fn outputs(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(CircuitTable::VT_OUTPUTS, None)}
  }
  #[inline]
  pub fn output_datatypes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataTypeTable<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataTypeTable>>>>(CircuitTable::VT_OUTPUT_DATATYPES, None)}
  }
  #[inline]
  pub fn nodes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<NodeTable<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<NodeTable>>>>(CircuitTable::VT_NODES, None)}
  }
  #[inline]
  pub fn circuit_annotations(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CircuitTable::VT_CIRCUIT_ANNOTATIONS, None)}
  }
}

impl flatbuffers::Verifiable for CircuitTable<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>("inputs", Self::VT_INPUTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DataTypeTable>>>>("input_datatypes", Self::VT_INPUT_DATATYPES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>("outputs", Self::VT_OUTPUTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DataTypeTable>>>>("output_datatypes", Self::VT_OUTPUT_DATATYPES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<NodeTable>>>>("nodes", Self::VT_NODES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("circuit_annotations", Self::VT_CIRCUIT_ANNOTATIONS, false)?
     .finish();
    Ok(())
  }
}
pub struct CircuitTableArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub inputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
    pub input_datatypes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataTypeTable<'a>>>>>,
    pub outputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
    pub output_datatypes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataTypeTable<'a>>>>>,
    pub nodes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<NodeTable<'a>>>>>,
    pub circuit_annotations: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CircuitTableArgs<'a> {
  #[inline]
  fn default() -> Self {
    CircuitTableArgs {
      name: None, // required field
      inputs: None,
      input_datatypes: None,
      outputs: None,
      output_datatypes: None,
      nodes: None,
      circuit_annotations: None,
    }
  }
}

pub struct CircuitTableBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CircuitTableBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CircuitTable::VT_NAME, name);
  }
  #[inline]
  pub fn add_inputs(&mut self, inputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CircuitTable::VT_INPUTS, inputs);
  }
  #[inline]
  pub fn add_input_datatypes(&mut self, input_datatypes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DataTypeTable<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CircuitTable::VT_INPUT_DATATYPES, input_datatypes);
  }
  #[inline]
  pub fn add_outputs(&mut self, outputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CircuitTable::VT_OUTPUTS, outputs);
  }
  #[inline]
  pub fn add_output_datatypes(&mut self, output_datatypes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DataTypeTable<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CircuitTable::VT_OUTPUT_DATATYPES, output_datatypes);
  }
  #[inline]
  pub fn add_nodes(&mut self, nodes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<NodeTable<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CircuitTable::VT_NODES, nodes);
  }
  #[inline]
  pub fn add_circuit_annotations(&mut self, circuit_annotations: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CircuitTable::VT_CIRCUIT_ANNOTATIONS, circuit_annotations);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CircuitTableBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CircuitTableBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CircuitTable<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, CircuitTable::VT_NAME,"name");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CircuitTable<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CircuitTable");
      ds.field("name", &self.name());
      ds.field("inputs", &self.inputs());
      ds.field("input_datatypes", &self.input_datatypes());
      ds.field("outputs", &self.outputs());
      ds.field("output_datatypes", &self.output_datatypes());
      ds.field("nodes", &self.nodes());
      ds.field("circuit_annotations", &self.circuit_annotations());
      ds.finish()
  }
}
pub enum CircuitTableBufferOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CircuitTableBuffer<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CircuitTableBuffer<'a> {
  type Inner = CircuitTableBuffer<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CircuitTableBuffer<'a> {
  pub const VT_CIRCUIT_BUFFER: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CircuitTableBuffer { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CircuitTableBufferArgs<'args>
  ) -> flatbuffers::WIPOffset<CircuitTableBuffer<'bldr>> {
    let mut builder = CircuitTableBufferBuilder::new(_fbb);
    if let Some(x) = args.circuit_buffer { builder.add_circuit_buffer(x); }
    builder.finish()
  }


  #[inline]
  pub fn circuit_buffer(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(CircuitTableBuffer::VT_CIRCUIT_BUFFER, None)}
  }
  pub fn circuit_buffer_nested_flatbuffer(&'a self) -> Option<CircuitTable<'a>> {
    self.circuit_buffer().map(|data| {
      use flatbuffers::Follow;
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid flatbuffer in this slot
      unsafe { <flatbuffers::ForwardsUOffset<CircuitTable<'a>>>::follow(data.bytes(), 0) }
    })
  }
}

impl flatbuffers::Verifiable for CircuitTableBuffer<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("circuit_buffer", Self::VT_CIRCUIT_BUFFER, false)?
     .finish();
    Ok(())
  }
}
pub struct CircuitTableBufferArgs<'a> {
    pub circuit_buffer: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for CircuitTableBufferArgs<'a> {
  #[inline]
  fn default() -> Self {
    CircuitTableBufferArgs {
      circuit_buffer: None,
    }
  }
}

pub struct CircuitTableBufferBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CircuitTableBufferBuilder<'a, 'b> {
  #[inline]
  pub fn add_circuit_buffer(&mut self, circuit_buffer: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CircuitTableBuffer::VT_CIRCUIT_BUFFER, circuit_buffer);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CircuitTableBufferBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CircuitTableBufferBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CircuitTableBuffer<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CircuitTableBuffer<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CircuitTableBuffer");
      ds.field("circuit_buffer", &self.circuit_buffer());
      ds.finish()
  }
}
pub enum ModuleTableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ModuleTable<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ModuleTable<'a> {
  type Inner = ModuleTable<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ModuleTable<'a> {
  pub const VT_CIRCUITS: flatbuffers::VOffsetT = 4;
  pub const VT_ENTRY_POINT: flatbuffers::VOffsetT = 6;
  pub const VT_MODULE_ANNOTATIONS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ModuleTable { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ModuleTableArgs<'args>
  ) -> flatbuffers::WIPOffset<ModuleTable<'bldr>> {
    let mut builder = ModuleTableBuilder::new(_fbb);
    if let Some(x) = args.module_annotations { builder.add_module_annotations(x); }
    if let Some(x) = args.entry_point { builder.add_entry_point(x); }
    if let Some(x) = args.circuits { builder.add_circuits(x); }
    builder.finish()
  }


  #[inline]
  pub fn circuits(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CircuitTableBuffer<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CircuitTableBuffer>>>>(ModuleTable::VT_CIRCUITS, None)}
  }
  #[inline]
  pub fn entry_point(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ModuleTable::VT_ENTRY_POINT, None)}
  }
  #[inline]
  pub fn module_annotations(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ModuleTable::VT_MODULE_ANNOTATIONS, None)}
  }
}

impl flatbuffers::Verifiable for ModuleTable<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CircuitTableBuffer>>>>("circuits", Self::VT_CIRCUITS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("entry_point", Self::VT_ENTRY_POINT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("module_annotations", Self::VT_MODULE_ANNOTATIONS, false)?
     .finish();
    Ok(())
  }
}
pub struct ModuleTableArgs<'a> {
    pub circuits: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CircuitTableBuffer<'a>>>>>,
    pub entry_point: Option<flatbuffers::WIPOffset<&'a str>>,
    pub module_annotations: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ModuleTableArgs<'a> {
  #[inline]
  fn default() -> Self {
    ModuleTableArgs {
      circuits: None,
      entry_point: None,
      module_annotations: None,
    }
  }
}

pub struct ModuleTableBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ModuleTableBuilder<'a, 'b> {
  #[inline]
  pub fn add_circuits(&mut self, circuits: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CircuitTableBuffer<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ModuleTable::VT_CIRCUITS, circuits);
  }
  #[inline]
  pub fn add_entry_point(&mut self, entry_point: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ModuleTable::VT_ENTRY_POINT, entry_point);
  }
  #[inline]
  pub fn add_module_annotations(&mut self, module_annotations: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ModuleTable::VT_MODULE_ANNOTATIONS, module_annotations);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ModuleTableBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ModuleTableBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ModuleTable<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ModuleTable<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ModuleTable");
      ds.field("circuits", &self.circuits());
      ds.field("entry_point", &self.entry_point());
      ds.field("module_annotations", &self.module_annotations());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `ModuleTable`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_module_table_unchecked`.
pub fn root_as_module_table(buf: &[u8]) -> Result<ModuleTable, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<ModuleTable>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `ModuleTable` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_module_table_unchecked`.
pub fn size_prefixed_root_as_module_table(buf: &[u8]) -> Result<ModuleTable, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<ModuleTable>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `ModuleTable` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_module_table_unchecked`.
pub fn root_as_module_table_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ModuleTable<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<ModuleTable<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `ModuleTable` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_module_table_unchecked`.
pub fn size_prefixed_root_as_module_table_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ModuleTable<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<ModuleTable<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a ModuleTable and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `ModuleTable`.
pub unsafe fn root_as_module_table_unchecked(buf: &[u8]) -> ModuleTable {
  flatbuffers::root_unchecked::<ModuleTable>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed ModuleTable and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `ModuleTable`.
pub unsafe fn size_prefixed_root_as_module_table_unchecked(buf: &[u8]) -> ModuleTable {
  flatbuffers::size_prefixed_root_unchecked::<ModuleTable>(buf)
}
#[inline]
pub fn finish_module_table_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<ModuleTable<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_module_table_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<ModuleTable<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod ir
}  // pub mod fuse

